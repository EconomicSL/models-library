tradables.number = 4
market.referencePrice = 1

settlement{

  numberRoutees = 20

}

traders {

  number = 100

  params {

    timeUnit = "MILLISECONDS"

    limitOrderArrivalRate = 2.0

    orderCancellationArrivalRate = 1e-3

    marketOrderArrivalRate = 2.0

    askOrderProbability = 0.5

    minAskPrice = 1

    minBidPrice = 1

    maxAskPrice = 1000000

    maxBidPrice = 1000000

    minAskQuantity = 1

    minBidQuantity = 1

    maxAskQuantity = 10000

    maxBidQuantity = 10000

  }
}

market-dispatcher {

  # Dispatcher is the name of the event-based dispatcher
  type = Dispatcher

  # What kind of ExecutionService to use
  executor = "fork-join-executor"

  # Configuration for the fork join pool
  fork-join-executor {
    # Min number of threads to cap factor-based parallelism number to
    parallelism-min = 8

    # Parallelism (threads) ... ceil(available processors * factor)
    parallelism-factor = 3.0

    # Max number of threads to cap factor-based parallelism number to
    parallelism-max = 64
  }

  # Throughput defines the maximum number of messages to be
  # processed per actor before the thread jumps to the next actor.
  # Set to 1 for as fair as possible.
  throughput = 1000

}

akka {

  loggers = ["akka.event.slf4j.Slf4jLogger"]

  loglevel = "DEBUG"

  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  actor {

    debug {

      receive = off

    }

    default-dispatcher {

      executor = "fork-join-executor"

      fork-join-executor {
        # Min number of threads to cap factor-based parallelism number to
        parallelism-min = 8

        # The parallelism factor is used to determine thread pool size using the
        # following formula: ceil(available processors * factor). Resulting size
        # is then bounded by the parallelism-min and parallelism-max values.
        parallelism-factor = 3.0

        # Max number of threads to cap factor-based parallelism number to
        parallelism-max = 64

        # Setting to "FIFO" to use queue like peeking mode which "poll" or "LIFO" to use stack
        # like peeking mode which "pop".
        task-peeking-mode = "FIFO"
      }

      thread-pool-executor {

        # Keep alive time for threads
        keep-alive-time = 60s

        # Min number of threads to cap factor-based core number to
        core-pool-size-min = 100

        # The core pool size factor is used to determine thread pool core size
        # using the following formula: ceil(available processors * factor).
        # Resulting size is then bounded by the core-pool-size-min and
        # core-pool-size-max values.
        core-pool-size-factor = 3.0

        # Max number of threads to cap factor-based number to
        core-pool-size-max = 64

        # Minimum number of threads to cap factor-based max number to
        # (if using a bounded task queue)
        max-pool-size-min = 8

        # Max no of threads (if using a bounded task queue) is determined by
        # calculating: ceil(available processors * factor)
        max-pool-size-factor  = 3.0

        # Max number of threads to cap factor-based max number to
        # (if using a  bounded task queue)
        max-pool-size-max = 64

        # Specifies the bounded capacity of the task queue (< 1 == unbounded)
        task-queue-size = -1

        # Specifies which type of task queue will be used, can be "array" or
        # "linked" (default)
        task-queue-type = "linked"

        # Allow core threads to time out
        allow-core-timeout = on
      }

      throughput = 1

    }
  }

//  scheduler {
//
//    tick-duration = 1ms
//
//    ticks-per-wheel = 32768
//
//  }

}